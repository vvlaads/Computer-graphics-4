import math


def vec_sub(a, b):
    """Вычитание векторов: a - b"""
    return a[0] - b[0], a[1] - b[1], a[2] - b[2]


def vec_add(a, b):
    """Сложение векторов: a + b"""
    return a[0] + b[0], a[1] + b[1], a[2] + b[2]


def vec_scale(a, s):
    """Умножение вектора на скаляр: a * s"""
    return a[0] * s, a[1] * s, a[2] * s


def vec_dot(a, b):
    """Скалярное произведение векторов: a · b"""
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]


def vec_len(a):
    """Длина вектора (модуль вектора)"""
    return math.sqrt(vec_dot(a, a))


def vec_norm(a):
    """Нормализация вектора (приведение к единичной длине)"""
    length = vec_len(a)
    if length < 1e-12:
        return 0.0, 0.0, 0.0
    return a[0] / length, a[1] / length, a[2] / length


def intersection_with_sphere(obs, vec, center, radius):
    """
    Поиск пересечения луча со сферой
        Параметры:
        obs: кортеж (x, y, z) - точка начала луча (наблюдатель)
        vec: кортеж (x, y, z) - направляющий вектор луча (должен быть нормализован!)
        center: кортеж (x, y, z) - центр сферы
        radius: число - радиус сферы

        Возвращает:
            None - если луч не пересекает сферу
            Кортеж (x, y, z) - точку пересечения (ближайшую к наблюдателю)

        Решаем квадратное уравнение для параметра t:
            (obs + t*vec - center)² = radius²
    """
    # Вектор от наблюдателя к центру сферы
    obs_to_center = vec_sub(obs, center)

    # Коэффициенты квадратного уравнения
    a = vec_dot(vec, vec)  # Должно быть = 1, если vec нормализован
    b = 2.0 * vec_dot(vec, obs_to_center)  # Удвоенное скалярное произведение
    c = vec_dot(obs_to_center, obs_to_center) - radius * radius  # Свободный член

    # Дискриминант: D = B² - 4AC
    d = b * b - 4 * a * c

    # Нет корней
    if d < 0:
        return None  # нет пересечения

    # Находим корни квадратного уравнения
    sqrt_d = d ** 0.5
    t1 = (-b - sqrt_d) / (2 * a)
    t2 = (-b + sqrt_d) / (2 * a)

    # Выбираем только положительные корни (луч идет вперед, не назад)
    # t > 0 означает, что пересечение находится перед наблюдателем
    ts = [t for t in (t1, t2) if t > 1e-6]  # 1e-6 - маленькое число для учета погрешностей

    # Если нет положительных корней - сфера находится за наблюдателем
    if not ts:
        return None

    # Берем ближайшее пересечение (наименьший t)
    t = min(ts)

    # Вычисляем точку пересечения: наблюдатель + направление * расстояние
    point = vec_add(obs, vec_scale(vec, t))
    return point
